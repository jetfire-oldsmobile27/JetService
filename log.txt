include/restclient.h:
#pragma once
#include <string>
#include <boost/json.hpp>

namespace jetfire27::Engine::REST {

class RestClient {
public:
    RestClient(const std::string& base_url, int port = 80);
    
    void SetAuthToken(const std::string& token) { auth_token_ = token; }
    void ClearAuthToken() { auth_token_.clear(); }

    std::string Get(const std::string& target);
    std::string Post(const std::string& target, const boost::json::value& body);
    std::string Put(const std::string& target, const boost::json::value& body);
    std::string Delete(const std::string& target);

private:
    std::string build_full_url(const std::string& target);

    std::string base_url_;
    int port_;
    std::string auth_token_;
};

} // namespace jetfire27::Engine::REST
include/testserver.h:
#pragma once
#include "db.h"
#include "parser.h"
#include "restclient.h"

#include <boost/asio.hpp>

namespace jetfire27::Engine::Test {

    class TestServer {
    public:
        TestServer(unsigned short port, const std::string& dbPath);
        ~TestServer();
        void Run();
        void Stop();

    private:
        void HandleSession(boost::asio::ip::tcp::socket socket);

        unsigned short port_;
        jetfire27::Engine::DB::SQLiteDB db_;
        boost::asio::io_context ioc_;
        boost::asio::ip::tcp::acceptor acceptor_;
    };

}

include/parser.h:
#pragma once
#include <string>

namespace jetfire27::Engine::JsonParser {
    template<typename T>
    class Parser {
    public:
        std::string Marshall(const T& obj);
        T UnMarshall(const std::string& jsonStr);
    };
}

include/db.h:
#pragma once
#include <string>
#include <sqlite3.h>

namespace jetfire27::Engine::DB {
    class SQLiteDB {
    public:
        SQLiteDB(const std::string& dbPath);
        ~SQLiteDB();
        void Execute(const std::string& sql);
        // для выборок:
        void Execute(const std::string& sql,
                     int (*callback)(void*,int,char**,char**),
                     void* data);
    private:
        sqlite3* db = nullptr;
    };
}

include/testrecord.h:
#pragma once
#include <string>

namespace jetfire27::Engine::Test {
    struct TestRecord {
        int id;
        std::string name;
    };
}

include/daemonizer.h:
#pragma once
#include <string>

namespace jetfire27::Engine {
    enum class Mode { AutoStart, Service };

    class Daemonizer {
    public:
        static void Setup(const std::string& binPath, Mode mode);
        static void Remove(Mode mode);
        static bool IsSingleInstance(); 
    };
}

src/db.cpp:
#include "db.h"
#include <stdexcept>

using namespace jetfire27::Engine::DB;

SQLiteDB::SQLiteDB(const std::string& dbPath) {
    if (sqlite3_open(dbPath.c_str(), &db) != SQLITE_OK)
        throw std::runtime_error("Cannot open or create DB");
}

SQLiteDB::~SQLiteDB() {
    if (db) sqlite3_close(db);
}

void SQLiteDB::Execute(const std::string& sql) {
    char* err = nullptr;
    if (sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &err) != SQLITE_OK) {
        std::string e{err};
        sqlite3_free(err);
        throw std::runtime_error(e);
    }
}

void SQLiteDB::Execute(const std::string& sql,
                       int (*callback)(void*,int,char**,char**),
                       void* data)
{
    char* err = nullptr;
    if (sqlite3_exec(db, sql.c_str(), callback, data, &err) != SQLITE_OK) {
        std::string e{err};
        sqlite3_free(err);
        throw std::runtime_error(e);
    }
}

src/daemonizer.cpp:
#include "daemonizer.h"

#ifdef _WIN32
    #include <windows.h>
    #include <tchar.h>
#else
    #include <fstream>
    #include <unistd.h>
    #include <sys/file.h>
    #include <sys/stat.h>
#endif

using namespace jetfire27::Engine;

namespace {
    constexpr const char* SERVICE_NAME = "jetservice";
    constexpr const char* DESKTOP_FILE = "jetservice.desktop";
#ifdef _WIN32
    HANDLE instanceMutex = nullptr;
#else
    int lockFd = -1;
#endif
}

// ==========================
// Setup
// ==========================
void Daemonizer::Setup(const std::string& binPath, Mode mode) {
#ifdef _WIN32
    if (mode == Mode::AutoStart) {
        HKEY hKey;
        RegOpenKeyExA(HKEY_CURRENT_USER,
            "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
            0, KEY_WRITE, &hKey);
        RegSetValueExA(hKey, SERVICE_NAME, 0, REG_SZ,
                       (const BYTE*)binPath.c_str(), (DWORD)(binPath.size() + 1));
        RegCloseKey(hKey);
    } else {
        SC_HANDLE hSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!hSCManager) return;

    SC_HANDLE hService = CreateServiceA(
        hSCManager,
        SERVICE_NAME,
        "JetService Windows Daemon",
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        binPath.c_str(),
        nullptr, nullptr, nullptr, nullptr, nullptr
    );

    if (!hService) {
        // Service may already exist
        hService = OpenServiceA(hSCManager, SERVICE_NAME, SERVICE_ALL_ACCESS);
        if (hService) {
            ChangeServiceConfigA(hService,
                SERVICE_WIN32_OWN_PROCESS,
                SERVICE_AUTO_START,
                SERVICE_ERROR_NORMAL,
                binPath.c_str(),
                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
        }
    }

    if (hService) {
        StartServiceA(hService, 0, nullptr);
        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);
    }
#elif __APPLE__
    std::string plistPath = std::string(getenv("HOME")) + "/Library/LaunchAgents/" + SERVICE_NAME + ".plist";
    std::ofstream f(plistPath);
    f << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
         "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
         "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
         "<plist version=\"1.0\">\n"
         "<dict>\n"
         "    <key>Label</key>\n"
         "    <string>" << SERVICE_NAME << "</string>\n"
         "    <key>ProgramArguments</key>\n"
         "    <array><string>" << binPath << "</string></array>\n"
         "    <key>RunAtLoad</key>\n"
         "    <true/>\n"
         "</dict>\n"
         "</plist>\n";
#else
    if (mode == Mode::AutoStart) {
        std::string path = std::string(getenv("HOME")) + "/.config/autostart/" + DESKTOP_FILE;
        std::ofstream f(path);
        f << "[Desktop Entry]\n"
             "Type=Application\n"
             "Exec=" << binPath << "\n"
             "X-GNOME-Autostart-enabled=true\n"
             "Hidden=false\n";
    } else {
        std::ofstream f("/etc/systemd/system/" + std::string(SERVICE_NAME) + ".service");
        f << "[Unit]\nDescription=JetService Daemon\n\n"
             "[Service]\nExecStart=" << binPath << "\nRestart=always\n\n"
             "[Install]\nWantedBy=multi-user.target\n";
        // Activate via systemctl if needed
        // system("systemctl daemon-reexec && systemctl enable --now jetservice-driver");
    }
#endif
}

// ==========================
// Remove
// ==========================
void Daemonizer::Remove(Mode mode) {
#ifdef _WIN32
    if (mode == Mode::AutoStart) {
        HKEY hKey;
        RegOpenKeyExA(HKEY_CURRENT_USER,
                      "Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                      0, KEY_WRITE, &hKey);
        RegDeleteValueA(hKey, SERVICE_NAME);
        RegCloseKey(hKey);
    } else {
        SC_HANDLE hSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!hSCManager) return;

    SC_HANDLE hService = OpenServiceA(hSCManager, SERVICE_NAME, SERVICE_STOP | DELETE);
    if (hService) {
        SERVICE_STATUS status;
        ControlService(hService, SERVICE_CONTROL_STOP, &status);
        DeleteService(hService);
        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);
    }
#elif __APPLE__
    std::string plistPath = std::string(getenv("HOME")) + "/Library/LaunchAgents/" + SERVICE_NAME + ".plist";
    std::remove(plistPath.c_str());
#else
    if (mode == Mode::AutoStart) {
        std::string path = std::string(getenv("HOME")) + "/.config/autostart/" + DESKTOP_FILE;
        std::remove(path.c_str());
    } else {
        std::string svcPath = "/etc/systemd/system/" + std::string(SERVICE_NAME) + ".service";
        std::remove(svcPath.c_str());
        // Optionally disable service
        // system("systemctl disable --now jetservice-driver");
    }
#endif
}

bool Daemonizer::IsSingleInstance() {
#ifdef _WIN32
    instanceMutex = CreateMutexA(nullptr, TRUE, "Global\\jetserviceMutex");
    return (GetLastError() != ERROR_ALREADY_EXISTS);
#else
    std::string lockFile = "/tmp/" + std::string(SERVICE_NAME) + ".lock";
    lockFd = open(lockFile.c_str(), O_CREAT | O_RDWR, 0666);
    if (lockFd < 0) return false;
    if (flock(lockFd, LOCK_EX | LOCK_NB) != 0) return false;
    return true;
#endif
}

src/restclient.cpp:
#include "restclient.h"
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/asio.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/beast/version.hpp>
#include <stdexcept>
#include <string>

using namespace boost;
using tcp  = asio::ip::tcp;
namespace http = beast::http;
namespace json = boost::json;

namespace {

std::string do_request_no_body(
    http::verb method,
    const std::string& host,
    int port,
    const std::string& target,
    const std::string& auth_token
) {
    asio::io_context ioc;
    tcp::resolver resolver(ioc);
    beast::tcp_stream stream(ioc);

    auto const results = resolver.resolve(host, std::to_string(port));
    stream.connect(results);

    http::request<http::empty_body> req{method, target, 11};
    req.set(http::field::host, host);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);
    if (!auth_token.empty()) {
        req.set(http::field::authorization, "Bearer " + auth_token);
    }
    req.prepare_payload();

    http::write(stream, req);
    beast::flat_buffer buffer;
    http::response<http::string_body> res;
    http::read(stream, buffer, res);
    stream.socket().shutdown(tcp::socket::shutdown_both);

    if (res.result() != http::status::ok) {
        throw std::runtime_error(
            "HTTP error " + std::to_string(res.result_int())
            + ": " + std::string(res.reason())
        );
    }
    return res.body();
}

std::string do_request_with_body(
    http::verb method,
    const std::string& host,
    int port,
    const std::string& target,
    const std::string& auth_token,
    const std::string& body_json
) {
    asio::io_context ioc;
    tcp::resolver resolver(ioc);
    beast::tcp_stream stream(ioc);

    auto const results = resolver.resolve(host, std::to_string(port));
    stream.connect(results);

    http::request<http::string_body> req{method, target, 11};
    req.set(http::field::host, host);
    req.set(http::field::user_agent, BOOST_BEAST_VERSION_STRING);
    req.set(http::field::content_type, "application/json");
    if (!auth_token.empty()) {
        req.set(http::field::authorization, "Bearer " + auth_token);
    }
    req.body() = body_json;
    req.prepare_payload();

    http::write(stream, req);
    beast::flat_buffer buffer;
    http::response<http::string_body> res;
    http::read(stream, buffer, res);
    stream.socket().shutdown(tcp::socket::shutdown_both);

    if (res.result() != http::status::ok) {
        throw std::runtime_error(
            "HTTP error " + std::to_string(res.result_int())
            + ": " + std::string(res.reason())
        );
    }
    return res.body();
}

} // namespace

jetfire27::Engine::REST::RestClient::RestClient(
    const std::string& base_url,
    int port
) : base_url_(base_url), port_(port) {}

std::string jetfire27::Engine::REST::RestClient::Get(const std::string& target) {
    return do_request_no_body(
        http::verb::get,
        base_url_,
        port_,
        target,
        auth_token_
    );
}

std::string jetfire27::Engine::REST::RestClient::Delete(const std::string& target) {
    return do_request_no_body(
        http::verb::delete_,
        base_url_,
        port_,
        target,
        auth_token_
    );
}

std::string jetfire27::Engine::REST::RestClient::Post(
    const std::string& target,
    const json::value& body
) {
    return do_request_with_body(
        http::verb::post,
        base_url_,
        port_,
        target,
        auth_token_,
        json::serialize(body)
    );
}

std::string jetfire27::Engine::REST::RestClient::Put(
    const std::string& target,
    const json::value& body
) {
    return do_request_with_body(
        http::verb::put,
        base_url_,
        port_,
        target,
        auth_token_,
        json::serialize(body)
    );
}

src/testserver.cpp:
#include "testserver.h"
#include "testrecord.h"

#include <boost/asio.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/beast/core.hpp>
#include <boost/beast/http.hpp>
#include <boost/beast/version.hpp>
#include <boost/json.hpp>

namespace asio  = boost::asio;
namespace beast = boost::beast;
namespace http  = beast::http;
namespace json  = boost::json;
using   tcp    = asio::ip::tcp;

using jetfire27::Engine::Test::TestServer;
using jetfire27::Engine::Test::TestRecord;

namespace jetfire27::Engine::JsonParser {
    template<>
    inline std::string Parser<TestRecord>::Marshall(const TestRecord& o) {
        json::object j;
        j["id"]   = o.id;
        j["name"] = o.name;
        return json::serialize(j);
    }
    template<>
    inline TestRecord Parser<TestRecord>::UnMarshall(const std::string& s) {
        auto o = json::parse(s).as_object();
        return TestRecord{
            int(o["id"].as_int64()),
            std::string(o["name"].as_string())
        };
    }
}

TestServer::TestServer(unsigned short port, const std::string& dbPath)
    : port_(port), db_(dbPath), ioc_(), acceptor_{ioc_, {tcp::v4(), port_}}
{
    db_.Execute(
      "CREATE TABLE IF NOT EXISTS test ("
      "id INTEGER PRIMARY KEY AUTOINCREMENT, "
      "name TEXT NOT NULL);"
    );
}

TestServer::~TestServer() { Stop(); }

void TestServer::Run() {
    try {
        for (;;) {
            tcp::socket sock{ioc_};
            acceptor_.accept(sock);           
            HandleSession(std::move(sock));
        }
    } catch (const std::exception& e) {
        std::fprintf(stderr, "Server stopped critical: %s\n", e.what());
    }
}

void TestServer::Stop() {
    boost::system::error_code ec;
    acceptor_.close(ec);
    ioc_.stop();
}

void TestServer::HandleSession(tcp::socket socket) {
    beast::tcp_stream stream(std::move(socket));
    beast::flat_buffer buf;
    http::request<http::string_body> req;
    http::read(stream, buf, req);

    http::response<http::string_body> res{http::status::ok, req.version()};
    res.set(http::field::content_type, "application/json");
    res.keep_alive(req.keep_alive());

    if (req.method() == http::verb::get && req.target() == "/items") {
        // C-style callback for sqlite3_exec
        struct CB { static int f(void* d,int c,char**v,char**){
            auto vec = static_cast<std::vector<TestRecord>*>(d);
            vec->push_back({ std::stoi(v[0]), v[1] });
            return 0;
        }};
        std::vector<TestRecord> vec;
        db_.Execute("SELECT id,name FROM test;", CB::f, &vec);

        // avoid match with:contentReference[oaicite:11]{index=11}
        jetfire27::Engine::JsonParser::Parser<TestRecord> parser;
        json::array arr;
        for (auto& r : vec) {
            arr.push_back(json::parse(parser.Marshall(r)));
        }
        res.body() = json::serialize(arr);

    } else if (req.method() == http::verb::post && req.target() == "/items") {
        jetfire27::Engine::JsonParser::Parser<TestRecord> parser;
        auto rec = parser.UnMarshall(req.body());
        db_.Execute("INSERT INTO test(name) VALUES('" + rec.name + "');");
        res.body() = R"({"status":"ok"})";

    } else {
        res.result(http::status::bad_request);
        res.body() = R"({"error":"bad request"})";
    }

    res.prepare_payload();
    http::write(stream, res);
    stream.socket().shutdown(tcp::socket::shutdown_send);
}

src/parser.cpp:
#include "parser.h"
src/main.cpp:
#include <cstdio>
#include <iostream>
#include <thread>
#include <memory>
#include <optional>
#include <string>


#include "testserver.h" 
#include "daemonizer.h"   

#if defined(_WIN32) || defined(_WIN64)
#  define TRAY_WINAPI 1
#elif defined(__linux__)
#  define TRAY_APPINDICATOR 1
#elif defined(__APPLE__)
#  define TRAY_APPKIT 1
#endif

#if TRAY_APPINDICATOR
#  define TRAY_ICON1 "indicator-messages"
#  define TRAY_ICON2 "indicator-messages-new"
#elif TRAY_APPKIT
#  define TRAY_ICON1 "icon.png"
#  define TRAY_ICON2 "icon.png"
#elif TRAY_WINAPI
#  define TRAY_ICON1 "assets/icon.ico"
#  define TRAY_ICON2 "assets/icon.ico"
#endif

#include "../thirdparty/tray.h"  

using jetfire27::Engine::Test::TestServer;

static std::unique_ptr<TestServer>  g_server;
static std::optional<std::thread>   g_thread;

static void start_server() {
    if (g_thread && g_thread->joinable()) {return;};

    g_server = std::make_unique<TestServer>(8080, "test.db");
    g_thread.emplace(&TestServer::Run, g_server.get());
}

static void stop_server() {
    if (g_server) {
        g_server->Stop();
    }
    if (g_thread && g_thread->joinable()) {
        g_thread->join();
    }
    g_thread.reset();        
    g_server.reset();        
}

static void status_cb(struct tray_menu* /*item*/) {
    std::printf("[Tray] service is running\n");
}

static void restart_cb(struct tray_menu* /*item*/) {
    std::printf("[Tray] restarting service...\n");
    stop_server();
    start_server();
    std::printf("[Tray] service restarted\n");
}

static void quit_cb(struct tray_menu* /*item*/) {
    tray_exit();
}

static struct tray_menu g_menu[] = {
    { (char*)"Посмотреть статус", 0, 0, status_cb,  nullptr, nullptr },
    { (char*)"Перезапуск",        0, 0, restart_cb, nullptr, nullptr },
    { (char*)"-",                 0, 0, nullptr,     nullptr, nullptr },
    { (char*)"Выйти",             0, 0, quit_cb,    nullptr, nullptr },
    { nullptr,                    0, 0, nullptr,     nullptr, nullptr }
};

static struct tray g_tray = {
    (char*)TRAY_ICON1,
    g_menu
};

std::string getExecutablePath() {
#ifdef _WIN32
    char path[MAX_PATH];
    GetModuleFileNameA(nullptr, path, MAX_PATH);
    return std::string(path);
#elif __APPLE__ || __linux__
    char path[4096];
    ssize_t len = readlink("/proc/self/exe", path, sizeof(path)-1);
    if (len != -1) {
        path[len] = '\0';
        return std::string(path);
    }
    return {};
#endif
}

int main(int /*argc*/, char** /*argv*/) {
    if (!jetfire27::Engine::Daemonizer::IsSingleInstance()) {
        std::cerr << "Already running\n";
        return 1;
    }

    jetfire27::Engine::Daemonizer::Setup(getExecutablePath(), jetfire27::Engine::Mode::Service);
    start_server();
    
    if (tray_init(&g_tray) < 0) {
        std::fprintf(stderr, "Error: cannot initialize tray icon\n");
        stop_server();
        return 1;
    }

    while (tray_loop(1) == 0) {
    }

    std::printf("[Main] Exiting, stopping service...\n");
    stop_server();
    std::printf("[Main] Shutdown complete\n");
    return 0;
}

